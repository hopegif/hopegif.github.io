[{"title":"angular学习","date":"2017-02-17T01:42:47.000Z","path":"2017/02/17/angular学习/","text":"##angular学习知识 我该如何学习一个新东西 what how why 上官网 看hello-word 官方指南教程 找一些视频资料 技术系统博客 做demo 最后过渡你的项目中-什么是框架和库 库是由你亲自去调用对应的API，大部分功能逻辑由你自己去完成 框架就是一个大平台，提供了已经实现的功能 学习使用框架 ，就是学习框架的规则 SPA(单页面应用程序) 利用锚点改变网页内容1.监听hash的变化2.拿到hash值3.根据不同的hash发送不同的请求，拿到对应的html字符串4.将拿到的字符串绑定到页面容器中 var $container = $('.container') // 以下就是在单页应用中最简单的路由使用 window.addEventListener('hashchange', function () { var hash = window.location.hash.substr(1) console.log(hash) switch (hash) { case '/': renderHtml('/find-music.html') break case '/my': renderHtml('/my-music.html') break case '/friend': renderHtml('/friend.html') break default: $container.html('404 Not Found.') break } }) function renderHtml(url) { $.ajax({ url: url, type: 'get' }).then(function (data) { $container.html(data) }) } $('#btn').on('click', function () { $('#test').val('哈哈') }) 什么是AngularJS1.前端高级javascript框架2.轻松构建SPA应用程序3.通过指令扩展HTML，通过表达式绑定数据到HTML4.最大程度上解放了DOM操作 AngularJS 优缺点 优点：AngularJS模板功能强大丰富，自带了极其丰富的angular指令。AngularJS是完全可扩展的，与其他库的兼容效果很好，每一个功能可以修改或更换，以满足开发者独特的开发流程和功能的需求。AngularJS是一个比较完善的前端MVC框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；AngularJS是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。缺点：AngularJS强约束导致学习成本较高，对前端不友好。但遵守 AngularJS 的约定时，生产力会很高，对 后台服务器开发程序员友好。AngularJS不利于SEO，因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取。AngularJS作为 MVVM 框架，因为实现了数据的双向绑定，对于大数组、复杂对象会存在性能问题。","link":"","categories":[],"tags":[]},{"title":"第三方包的使用","date":"2017-02-14T07:23:05.000Z","path":"2017/02/14/知识点整理/","text":"服务端跳转和客户端跳转 window.location.href 让浏览器重定向到某个路径 get请求 res.redirect(‘跳转路径’) 用于http交互 关于一个集合中的文档内部的结构嵌套关系 123456789101112131415&#123; _id:1, name:'创业设计', parent_id:0&#125;&#123; _id:2, name:'数学物理', parent_id:0&#125;&#123; _id:3, name:'影视设计', parent_id:1&#125; 图片处理上传图片预览 图片裁切GraphicsMagick","link":"","categories":[],"tags":[]},{"title":"","date":"2017-02-14T01:12:16.675Z","path":"2017/02/14/在线教育管理平台/","text":"面试题前后端交互1.要先通过三次握手连接 2.当客户端与服务器建立连接完成之后，将用户输入的地址按照http协议封装成请求报文 然后通过网络发送给服务器 3.在以上的请求报文中，最后有一个空行，当有请求报文体的时候(POST请求),报文体数据 会在请求报文的报文头之后加一个空行，然后是报文体 请求头 第一行：请求方法 请求路径 协议版本号 以键值对组成的请求报文首部字段 key：value 空行 请求体 如果是普通表单POST请求，则报文体内容就是key=value&amp;key=value 如果是multipart-form/data的形式，则内容： 响应报文头 协议版本号 状态码 状态短语 响应首部字段 有key：value的格式组成 响应日期 Connection：key-alive表示连接 只有经过一段时间，没有通信之后会自动断开连接 这就是http的长连接 空行 响应报文体 HTTP客户端会根据服务端响应的消息数据做处理：浏览器会将响应报文体内容渲染到网页当中","link":"","categories":[],"tags":[]},{"title":"cookie-demo知识点","date":"2017-02-13T09:29:02.000Z","path":"2017/02/13/在Node中使用的第三方包/","text":"1234567891011121314151617181920const http=require(&apos;http&apos;)http.createServer((req,res) =&gt;&#123; //关于从http协议角度使用cookie //1.通过响应报文在报文头中加入一个字段：Set-Cookie值就是key=value的格式 //2.当浏览器收到服务端响应回来的数据的时候,发送响应头中有一个Set-Cookie //然后浏览器会将该Cookie对应的数据保存起来（会话Cookie,持久化） //当下一次浏览器再次访问该服务的时候，浏览器会自动将保存的所有Cookie放到请求报文头中都带上来 //然后服务端就可以根据当前客户端的请求报文中的cookie字段来进行判断 const cookie=req.headers.cookie if(!cookie)&#123; res.writeHead(200,&#123; &apos;Set-Cookie&apos;:&apos;isFirst=true&apos; &#125;) &#125; res.end(&apos;hello first&apos;) &#125;) .listen（5000，()=&gt;&#123; console.log(&apos;running&apos;)； &#125;） 在express中使用的中间件(cookie-parser)安装1yarn add cookie-parser 使用： import cookieParser from ‘cookie-parser’ //挂载cookie-parser中间件 放在路由之前 app.use(cookieParser()) //cookie-parser中间件做两件事儿 //req.cookies通过该中间件自动将当前请求报文中的cookie解析为一个对象挂载到req.cookie //res.cookie(name,value)通过res.cookie可以向当前请求客户端发送cookie数据 //登录成功，利用cookie记住用户名 res.cookie(‘username’,username) 浏览器端cookie document.cookie 12345678910111213141516171819function getCookies()&#123; var cookies=&#123;&#125;; document.cookie.split(';').forEach(function(cookie)&#123; if(cookies)&#123; var item=cookie.split('=') cookies[item[0].trim()]=item[1].trim() &#125; return cookies &#125;)&#125;var cookies=getCookies()if(cookies['username'])&#123; $('#username').val(cookies['username'])&#125;if(data.err_code===0)&#123; //登陆成功 document.cookie='username='$(#username).val()&#125; -cookie 适合于保存一些对安全性不太关心的业务-记住用户名 购物车-cookie在占用大小上有4kb的限制-cookie由于可以直接在客户端进行操作，所以不安全-例如 腾讯视频：如果使用cookie：isVIP=true来作为会员的校验 Session技术 /* 在request请求对象上回增加一个属性req.session req.session会自动根据当前请求客户端中携带的Session-key找到对应的存储数据对象 req.session.key=value 设置 req.session.key 获取 */ 1234567891011//配置挂载session的中间件 app.use(session(&#123; secret:'itcast', resave:false, saveUninititalized:true &#125;)) //登陆成功，通过session记录登陆状态 // req.session.isLogin=true req.session.manager=manager req.session.cookie.maxAge=1000*60*60*24*3//设置当前客户端登陆过期时间（3天） session不是新技术 而是在原有的cookie基础上做的一个更高级的状态管理+在客户端通过cookie保存钥匙+在服务端保存状态数据 取值：根据当前客户端的钥匙去取值 赋值：根据当前客户端的钥匙去赋值 cookie和session的区别 在Node中使用formidable处理文件上传第一：安装1yarn add formidable 第二：基本使用12345var formidable=require('formidable'), http=require('http'), util=require('util')....","link":"","categories":[],"tags":[]},{"title":"mongodb知识点","date":"2017-02-10T01:10:20.000Z","path":"2017/02/10/mongodb知识点/","text":"知识点MongoDB存储结构 一个计算机可以由一个数据库服务实例 一个数据服务实例上可以有多个数据库 一个数据库中可以有多个集合 集合根据数据的业务类型划分 例如 用户数据、商品信息数据、广告信息数据 对数据进行分门别类的存储 集合在mongodb中就类似于数组 一个集合中可以有多个文档 文档在mongodb中就是一个类似于josn的数据对象 文档对象是动态的 可以随意的生成 为了便于管理，最好一个集合中存储的数据一定要保持文档结构的统一 12345678910111213&#123; collection1:[ &#123;文档1&#125;, &#123;文档2&#125;, &#123;文档3&#125; ], collection2：[ ], collection3:[ ]&#125; mongoose 安装： 1yarn add mongoose 在node中使用formidable处理文件上传 第一：安装 npm install –save formidable 官方文档：npmjs","link":"","categories":[],"tags":[]},{"title":"jsonp知识点","date":"2017-02-08T11:58:30.000Z","path":"2017/02/08/jsonp知识点/","text":"核心原理 123456&lt;script src=\"http:127.0.0.1:3000\"&gt;&lt;script&gt;&lt;script&gt; //异步请求跨域限制（ajax） //不同域名 协议 端口号&lt;/script&gt; Yarn Yarn 是一个Facebook开源的一个类似于npm的一个包管理工具 安装： 1npm install -g yarn 使用： yarn add 包名@版本号 –offline 本地必须有 yarn init =》npm init yarn add 包名 =》npm install –save 包名 yarn install =》 npm install yarn remove 包名 =》npm uninstall 包名 yarn global add 包名 =》npm install -g 包名 yarn global remove 包名 =》","link":"","categories":[],"tags":[]},{"title":"复习Express","date":"2017-02-08T01:16:43.000Z","path":"2017/02/08/复习Express/","text":"–save和–save-dev 前者是依赖保存到package.json文件中的dependencies选项中 后者，是保存到devDependencies选项中 两者都是通过执行 npm install 来安装依赖包 后者 在上线运行的时候 开发依赖项就不在需要了 就可以通过 npm install –production 命令仅仅安装dependencies babel 转码器 babel-cli：命令行转码 babel-register：实时转码，实用开发环境 babel-core：调用babel的api进行转码 babel-cli： 一种方式就是全局安装：npm install -g babel-cli 只要全局安装了 就会在命令行多出一个命令：babel 通过 npm root -g查看全局包的安装目录 这里如果使用全局安装了babel-cli进行转码是没有问题的，如果一旦项目给了别人，别人不知道你使用了这个转码工具，解决方式就是将 babel-cli安装到本地项目中（npm install –save-dev babel-cli） 这种第三方命令行工具如果安装到本地项目，会在node_modules中生成一个目录bin，然后第三方命令工具会将可执行文件放到该目录中 如果使用 则通过packagejson文件中的scripts字段来配置使用(npm run build) babel-register:(适合开发阶段实时编码转换) 第一：安装babel-register1npm install --save-dev babel-register 第二：添加一个傀儡文件（main.js） 123require('babel-register')require('你的核心功能代码入口文件')//开发阶段的（'./src/app'） 第三:使用node执行main.js 而不是你的入口文件 生产环境：把node_modules删掉 然后安装npm install –production Express 基于Node.js平台，快速，开发web框架hello world 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//app.js 需要1：用户访问/响应hello worldconst express=require('express');//1.调用express（）方法 得到一个app实例接口对象const app=express()//这个表示一个中间件//任何请求进来都会执行对应的处理函数//改代码内部如果不发送响应或者不做进一步处理代码会一直停在这里app.use(function(req,res,next)&#123; //cosole.log('111') //res.end('hello express') const urlPath=req.path 不包括查询字符串 // if(req.path.startsWith('public/')&#123; const filePath=`.$&#123;urlPath&#125;`//这里加.的原因是 //因为如果读文件是以/开头会去当前文件的根目录 fs.readFile(filePath,(err,data)=&gt;&#123; if(err)&#123; return res.end('404 not found') &#125; res.end(data) &#125;) &#125;else&#123; next()//如果请求路径不是以/public/开头的，则调用next函数（不确定） //这里调用next的目的就是告诉express继续往后执行:中间件 //具体执行哪个中间件，取决于对应的中间件的类型 &#125; next() &#125;)//2.通过app设置对应的路径 对应的请求处理函数//回调处理函数中://req 请求对象：用来获取当前客户端的请求数据或者请求报文信息//例如 req.query用来获取查询字符串数据 req.method用来当前请求方法//res响应对象:用来向当前请求客户端发送消息数据// 例如 res.write('响应数据') res.end（）结束响应app.get('/',function(req,res)&#123; res.write(\"hello\") res.end() //end用来结束响应的同时发送响应数据 &#125;) //3.开启监听 启动服务器 app.listen(3000,function()&#123; console.log(\"running\") &#125;) 基本路由 根据不同的请求路径分发到具体的请求处理函数 处理静态资源模板引擎中间件中间件：用来处理http请求的一个具体的环节（可能要执行某个具体的处理函数）中间件一般都是通过修改req或者res对象来为后续的处理提供便利的使用中间件分类：use(function(req,res,next){})不关心请求方法和请求路径 没有具体路由规则，任何请求都能进来use（’请求路径’,function（req，res，next）{}）不关心请求方法，只关心请求路径的中间件get(‘请求路径’，function(req,res,next){}) 具体路由规则中间件post(“请求路径”，function(req,res,next){})中间件的作用： 1.处理静态资源 12345678910111213141516171819202122app.use('/public',express.static('开放目录的路径'))app.use((req,res,next)=&gt;&#123; console.log(111); next()&#125;)app.use((req,res,next)=&gt;&#123; console.log(222); //在http中 没有请求就没有响应，服务端不可能主动给客户端发请求 //对于一次请求来说 只能响应一次 只有第一次生效 next();&#125;)//关系请求路径app.use('/a',(req,res,next)=&gt;&#123; console.log('use/a');&#125;)app.use((req,res,next)=&gt;&#123; console.log(333);&#125;) 中间件-404 12345678const express=require('express')const app=express() //404 处理放在最后app.use((req,res,nex)=&gt;&#123;res.end('404') &#125;) `","link":"","categories":[],"tags":[]},{"title":"ECMAScript入门","date":"2017-02-07T04:28:48.000Z","path":"2017/02/07/ECMAScript入门/","text":"知识点Ecmascript 6 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。 Ecmascript 是 JavaScript 语言的标注规范 let和const let类似于var,也是用来定义变量的 通过let定义的变量是块级作用域，只在当前代码块有效 const也类似于var，用来定义常量 通过const定义的常量，定义的时候必须初始化 let和const都没有作用域提升 let和const在一个块作用域中都不能重复定义 解构赋值数据解构： 1234567891011121314151617let [a,b,c]=[123,456,788]console.log(a,b,c) //123 456 789//let的用处&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; var lis = document.querySelectorAll('li') for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function () &#123; alert(i) &#125; &#125; console.log(i) 对象解构： 12let &#123;name,age&#125;=&#123;name:'jack',age:18&#125;console.log(name,age)//jack 18 函数参数解构:1234function f(p1,&#123;p2='aa',p3='bb'&#125;)&#123; console.log(p1,p2,p3)&#125;f('p1',&#123;p2:'p2'&#125;) //p1 p2 bb 字符串结构12let [a,b,c,d,e]='hello'console.log(a,b,c,d,e) //h e l l o //模板字符串：凡是以后需要字符串拼接的地方都使用模板字符串12let name='jack',time='today'`hell $(name),how are you $(time)` 数组的扩展 Array.from()将它转为真正的数组 Array.of()将一组值，转为数组 find()用于找出第一个符合条件的数组成员 123[1,5,10,15].find(function(value,index,arr)&#123; return value&gt;9; &#125;) 4.findIndex方法返回第一个符合条件的数组成员的位置 箭头函数12345678910111213141516let f=function(v)&#123; return v&#125;let f=v=&gt;v+'a'console.log(f(1))//如果有多个参数则必须加括号let add=(x,y)=&gt;x+yconsole.log(add(10,20))//如果方法有多条执行语法，则必须加&#123;&#125;let add=(x,y)=&gt;&#123; console.log(x,y) return x+y&#125;//箭头函数最好用在匿名函数的地方let arr=[1,2,3]arr.forEach(n=&gt;console.log(n))","link":"","categories":[],"tags":[]},{"title":"svn","date":"2017-02-06T02:00:04.000Z","path":"2017/02/06/svn/","text":"SVN知识点","link":"","categories":[],"tags":[]},{"title":"Git入门指南","date":"2017-02-05T10:54:43.000Z","path":"2017/02/05/Git入门指南/","text":"知识点 Git Github 项目阶段 Git-bash文件操作相关命令 touch 创建文件 cat 查看文件 less 查看大文本文件 vi visual interface Esc 退出到命令模式 i 进入插入模式 :q 退出vi :w 保存编辑 :wq 保存并退出 Git基本命令 git init 创建版本管理仓库 git status 查看仓库状态 git add 文件名 添加改动到暂存区 git commit -m ‘创建日志’ 提交到本地仓库 历史记录 git log 查看提交日志 添加/删除文件","link":"","categories":[],"tags":[]}]